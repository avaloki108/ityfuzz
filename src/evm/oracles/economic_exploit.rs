use std::{
    collections::hash_map::DefaultHasher,
    hash::{Hash, Hasher},
};

use bytes::Bytes;
use revm_primitives::Bytecode;

use crate::evm::{
    input::{ConciseEVMInput, EVMInput},
    oracle::EVMBugResult,
    oracles::ECONOMIC_EXPLOIT_BUG_IDX,
    types::{EVMAddress, EVMFuzzState, EVMOracleCtx, EVMQueueExecutor, EVMU256, EVMU512},
    vm::EVMState,
};
use crate::oracle::{Oracle, OracleCtx};
use crate::oracle_should_skip;
use crate::state::HasExecutionResult;

/// Economic exploit oracle (placeholder implementation).
///
/// The enhancement stub was written against a different oracle interface.
pub struct EconomicExploitOracle;

impl EconomicExploitOracle {
    pub fn new() -> Self {
        Self
    }
}

impl Default for EconomicExploitOracle {
    fn default() -> Self {
        Self::new()
    }
}

impl
    Oracle<
        EVMState,
        EVMAddress,
        Bytecode,
        Bytes,
        EVMAddress,
        EVMU256,
        Vec<u8>,
        EVMInput,
        EVMFuzzState,
        ConciseEVMInput,
        EVMQueueExecutor,
    > for EconomicExploitOracle
{
    fn transition(&self, _ctx: &mut EVMOracleCtx<'_>, _stage: u64) -> u64 {
        0
    }

    fn oracle(
        &self,
        ctx: &mut OracleCtx<
            EVMState,
            EVMAddress,
            Bytecode,
            Bytes,
            EVMAddress,
            EVMU256,
            Vec<u8>,
            EVMInput,
            EVMFuzzState,
            ConciseEVMInput,
            EVMQueueExecutor,
        >,
        _stage: u64,
    ) -> Vec<u64> {
        let fl = &ctx.post_state.flashloan_data;

        let has_signal = fl.owed != EVMU512::ZERO
            || fl.earned != EVMU512::ZERO
            || !fl.unliquidated_tokens.is_empty()
            || !fl.oracle_recheck_reserve.is_empty()
            || !fl.oracle_recheck_balance.is_empty();

        if !has_signal {
            return vec![];
        }

        // Stable bug id based on flashloan values.
        let mut hasher = DefaultHasher::new();
        fl.owed.hash(&mut hasher);
        fl.earned.hash(&mut hasher);
        fl.unliquidated_tokens.len().hash(&mut hasher);
        let real_bug_idx = (hasher.finish() << 8) + ECONOMIC_EXPLOIT_BUG_IDX;

        if oracle_should_skip!(ctx, real_bug_idx) {
            return vec![];
        }

        EVMBugResult::new_simple(
            "Economic Exploit".to_string(),
            real_bug_idx,
            format!(
                "Economic-signal observed (flashloan owed={}, earned={}, unliquidated_tokens={})", 
                fl.owed,
                fl.earned,
                fl.unliquidated_tokens.len()
            ),
            ConciseEVMInput::from_input(ctx.input, ctx.fuzz_state.get_execution_result()),
        )
        .push_to_output();

        vec![real_bug_idx]
    }
}